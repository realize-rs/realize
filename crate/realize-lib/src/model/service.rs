//! Service definition for Realize - Symmetric File Syncer
//!
//! This module defines the RealizeService trait for use with tarpc 0.36.

// Don't warn about types generated by tarpc::service.
#![allow(clippy::too_many_arguments)]

use std::path::PathBuf;

use crate::model::byterange::{ByteRange, ByteRanges};
use base64::Engine as _;

pub type Result<T> = std::result::Result<T, RealizeError>;

#[derive(Debug, Clone, Eq, PartialEq, Hash, serde::Serialize, serde::Deserialize)]
pub struct DirectoryId(String);
impl From<String> for DirectoryId {
    fn from(value: String) -> Self {
        Self(value)
    }
}
impl From<&str> for DirectoryId {
    fn from(value: &str) -> Self {
        Self(value.to_string())
    }
}
impl std::fmt::Display for DirectoryId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.0)
    }
}
impl DirectoryId {
    pub fn as_str(&self) -> &str {
        &self.0
    }
    pub fn into_string(self) -> String {
        self.0
    }
}

#[derive(Debug, Clone, Eq, PartialEq, serde::Serialize, serde::Deserialize)]
pub struct SyncedFile {
    pub path: PathBuf,
    pub size: u64,
    pub state: SyncedFileState,
}

#[derive(Debug, Clone, Copy, Eq, PartialEq, serde::Serialize, serde::Deserialize)]
pub enum SyncedFileState {
    Final,
    Partial,
}

#[derive(Clone, Eq, PartialEq, serde::Serialize, serde::Deserialize)]
pub struct Hash(pub [u8; 32]);

impl Hash {
    fn base64(&self) -> String {
        base64::prelude::BASE64_STANDARD_NO_PAD.encode(&self.0)
    }

    pub fn zero() -> Self {
        Self([0u8; 32])
    }

    fn is_zero(&self) -> bool {
        for v in self.0 {
            if v != 0 {
                return false;
            }
        }

        true
    }
}

impl std::fmt::Debug for Hash {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self, f)
    }
}

impl std::fmt::Display for Hash {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.is_zero() {
            f.write_str("None")
        } else {
            f.write_str(&self.base64())
        }
    }
}

#[derive(Debug, Clone, Eq, PartialEq, serde::Serialize, serde::Deserialize)]
pub struct Signature(pub Vec<u8>);

#[derive(Debug, Clone, Eq, PartialEq, serde::Serialize, serde::Deserialize)]
pub struct Delta(pub Vec<u8>);

#[derive(Debug, Clone, Copy, Eq, PartialEq, serde::Serialize, serde::Deserialize, Default)]
pub struct Options {
    pub ignore_partial: bool,
}

#[derive(Debug, Clone, Eq, PartialEq, serde::Serialize, serde::Deserialize, Default)]
pub struct Config {
    /// Optional write rate limit in bytes per second.
    pub write_limit: Option<u64>,
}

/// The service trait for file synchronization.
#[tarpc::service]
pub trait RealizeService {
    /// List files in a directory
    async fn list(dir_id: DirectoryId, options: Options) -> Result<Vec<SyncedFile>>;

    /// Send a byte range of a file.
    ///
    /// The 'file_size' argument indicates the intended final size of the file. If the file is larger than this after writing, it should be truncated.
    async fn send(
        dir_id: DirectoryId,
        relative_path: PathBuf,
        range: ByteRange,
        file_size: u64,
        data: Vec<u8>,
        hash: Hash,
        options: Options,
    ) -> Result<()>;

    /// Read a byte range from a file, returning data and its hash
    async fn read(
        dir_id: DirectoryId,
        relative_path: PathBuf,
        range: ByteRange,
        options: Options,
    ) -> Result<(Vec<u8>, Hash)>;

    /// Mark a partial file as complete
    async fn finish(dir_id: DirectoryId, relative_path: PathBuf, options: Options) -> Result<()>;

    /// Compute a SHA-256 hash of the file at the given path (final or partial).
    async fn hash(
        dir_id: DirectoryId,
        relative_path: PathBuf,
        range: ByteRange,
        options: Options,
    ) -> Result<Hash>;

    /// Delete the file at the given path (both partial and final forms).
    async fn delete(dir_id: DirectoryId, relative_path: PathBuf, options: Options) -> Result<()>;

    /// Calculate a signature for the file at the given path and byte range.
    async fn calculate_signature(
        dir_id: DirectoryId,
        relative_path: PathBuf,
        range: ByteRange,
        options: Options,
    ) -> Result<Signature>;

    /// Compute a delta from the file at the given path and a given signature.
    ///
    /// Returns the delta and the hash of the data used to compute it.
    async fn diff(
        dir_id: DirectoryId,
        relative_path: PathBuf,
        range: ByteRange,
        signature: Signature,
        options: Options,
    ) -> Result<(Delta, Hash)>;

    /// Apply a delta to the file at the given path and byte range, verifying the hash
    async fn apply_delta(
        dir_id: DirectoryId,
        relative_path: PathBuf,
        range: ByteRange,
        file_size: u64,
        delta: Delta,
        hash: Hash,
        options: Options,
    ) -> Result<()>;

    /// Configure the service with the given config (e.g., set write rate limit).
    async fn configure(config: Config) -> Result<Config>;
}

/// Error type used by [RealizeService].
///
/// This is limited, to remain usable through a RPC.
#[derive(thiserror::Error, Debug, serde::Serialize, serde::Deserialize)]
pub enum RealizeError {
    /// Returned by the RealizeService when given an invalid request.
    #[error("Bad request: {0}")]
    BadRequest(String),

    #[error("I/O error: {0}")]
    Io(String),

    #[error("RSync {0:?} error: {1}")]
    Rsync(RsyncOperation, String),

    #[error("Unexpected: {0}")]
    Other(String),

    #[error("Hash mismatch")]
    HashMismatch,
}

#[derive(Debug, serde::Serialize, serde::Deserialize)]
pub enum RsyncOperation {
    Diff,
    Apply,
    Sign,
}

impl From<std::io::Error> for RealizeError {
    fn from(value: std::io::Error) -> Self {
        RealizeError::Io(value.to_string())
    }
}

impl From<anyhow::Error> for RealizeError {
    fn from(value: anyhow::Error) -> Self {
        RealizeError::Other(value.to_string())
    }
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct RangedHash {
    hashes: Vec<RangedHashEntry>,
}

#[derive(Clone, PartialEq, Eq, Debug)]
struct RangedHashEntry {
    range: ByteRange,
    hash: Hash,
}

impl std::fmt::Display for RangedHash {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.hashes.is_empty() {
            write!(f, "Empty")
        } else {
            let range = self.span();
            write!(f, "{}-{}", range.start, range.end)?;
            let complete = self.is_complete(range.end);
            if !complete {
                f.write_str(" INCOMPLETE")?;
            }
            f.write_str(": [")?;
            let mut first = true;
            for RangedHashEntry { range, hash } in &self.hashes {
                if !first {
                    write!(f, " ")?;
                }
                if complete {
                    write!(f, "{}: {}", range.start, hash)?;
                } else {
                    write!(f, "{}-{}: {}", range.start, range.end, hash)?;
                }
                first = false;
            }
            f.write_str("]")?;

            Ok(())
        }
    }
}

impl RangedHash {
    pub fn new() -> Self {
        Self { hashes: vec![] }
    }

    pub fn single(range: ByteRange, hash: Hash) -> Self {
        let mut hashes = Vec::new();
        hashes.push(RangedHashEntry { range, hash });
        RangedHash { hashes }
    }

    pub fn len(&self) -> usize {
        self.hashes.len()
    }

    pub fn is_empty(&self) -> bool {
        self.hashes.is_empty()
    }

    pub fn add(&mut self, range: ByteRange, hash: Hash) {
        self.hashes.push(RangedHashEntry { range, hash });
        self.hashes.sort_by_key(|e| e.range.clone());
    }

    pub fn span(&self) -> ByteRange {
        ByteRange {
            start: self.hashes.first().map_or(0, |e| e.range.start),
            end: self.hashes.last().map_or(0, |e| e.range.end),
        }
    }

    pub fn ranges(&self) -> ByteRanges {
        ByteRanges::from_range_refs(self.hashes.iter().map(|e| &e.range))
    }

    pub fn is_complete(&self, filesize: u64) -> bool {
        if self.hashes.is_empty() {
            return false;
        }
        let mut expected = 0;
        for e in &self.hashes {
            if e.range.start != expected {
                return false;
            }
            expected = e.range.end;
        }

        expected == filesize
    }
    pub fn diff(&self, other: &RangedHash) -> (ByteRanges, ByteRanges) {
        let mut matches = Vec::new();
        let mut mismatches = Vec::new();
        let mut i = 0;
        let mut j = 0;
        while i < self.hashes.len() && j < other.hashes.len() {
            let a = &self.hashes[i];
            let b = &other.hashes[j];
            if a.range == b.range {
                if a.hash == b.hash {
                    matches.push(a.range.clone());
                } else {
                    mismatches.push(a.range.clone());
                }
                i += 1;
                j += 1;
            } else if a.range.start < b.range.start {
                i += 1;
            } else {
                j += 1;
            }
        }

        (
            ByteRanges::from_ranges(matches),
            ByteRanges::from_ranges(mismatches),
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_rangedhash_single() {
        let mut hash = RangedHash { hashes: vec![] };
        hash.add(ByteRange { start: 0, end: 10 }, Hash([1; 32]));

        assert_eq!(ByteRange { start: 0, end: 10 }, hash.span());
        assert!(hash.is_complete(10));
        assert_eq!(
            "0-10: [0: AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE]",
            hash.to_string()
        );
    }

    #[test]
    fn test_rangedhash_multiple() {
        let mut hash = RangedHash { hashes: vec![] };
        hash.add(ByteRange { start: 0, end: 10 }, Hash([1; 32]));
        hash.add(ByteRange { start: 10, end: 20 }, Hash([2; 32]));
        assert_eq!(
            format!("{}", hash),
            format!("0-20: [0: {} 10: {}]", Hash([1; 32]), Hash([2; 32]))
        );
    }

    #[test]
    fn test_rangedhash_is_complete() {
        let mut incomplete = RangedHash { hashes: vec![] };
        incomplete.add(ByteRange { start: 0, end: 10 }, Hash([1; 32]));
        incomplete.add(ByteRange { start: 10, end: 20 }, Hash([2; 32]));
        assert_eq!(ByteRange { start: 0, end: 20 }, incomplete.span());

        assert!(incomplete.is_complete(20));
        assert!(!incomplete.is_complete(30));
        assert!(!incomplete.is_complete(10));
    }

    #[test]
    fn test_rangedhash_with_holes() {
        let mut incomplete = RangedHash { hashes: vec![] };
        incomplete.add(ByteRange { start: 0, end: 10 }, Hash([1; 32]));
        incomplete.add(ByteRange { start: 20, end: 30 }, Hash([2; 32]));

        assert_eq!(ByteRange { start: 0, end: 30 }, incomplete.span());
        assert!(!incomplete.is_complete(10));
        assert!(!incomplete.is_complete(20));
        assert!(!incomplete.is_complete(30));

        assert_eq!(
            format!(
                "0-30 INCOMPLETE: [0-10: {} 20-30: {}]",
                Hash([1; 32]),
                Hash([2; 32])
            ),
            incomplete.to_string()
        );
    }

    #[test]
    fn test_rangedhash_empty() {
        let empty = RangedHash { hashes: vec![] };
        assert_eq!(ByteRange { start: 0, end: 0 }, empty.span());
        assert!(!empty.is_complete(0));
        assert_eq!("Empty", empty.to_string());
    }

    #[test]
    fn test_rangedhash_diff() {
        let mut a = RangedHash { hashes: vec![] };
        a.add(ByteRange { start: 0, end: 10 }, Hash([1; 32]));
        a.add(ByteRange { start: 10, end: 20 }, Hash([2; 32]));
        let mut b = RangedHash { hashes: vec![] };
        b.add(ByteRange { start: 0, end: 10 }, Hash([1; 32]));
        b.add(ByteRange { start: 10, end: 20 }, Hash([3; 32]));

        let (matches, mismatches) = a.diff(&b);
        assert_eq!(matches, ByteRanges::for_range(ByteRange::new(0, 10)));
        assert_eq!(mismatches, ByteRanges::for_range(ByteRange::new(10, 20)));

        assert_eq!(a.diff(&b), b.diff(&a));
        assert_eq!(
            a.diff(&a),
            (
                ByteRanges::for_range(ByteRange::new(0, 20)),
                ByteRanges::new()
            )
        );
    }

    #[test]
    fn test_rangedhash_eq_ignores_add_order() {
        let mut unordered_add = RangedHash { hashes: vec![] };
        unordered_add.add(ByteRange { start: 10, end: 20 }, Hash([2; 32]));
        unordered_add.add(ByteRange { start: 0, end: 10 }, Hash([1; 32]));

        let mut ordered_add = RangedHash { hashes: vec![] };
        ordered_add.add(ByteRange { start: 0, end: 10 }, Hash([1; 32]));
        ordered_add.add(ByteRange { start: 10, end: 20 }, Hash([2; 32]));

        assert_eq!(unordered_add, ordered_add);
    }
}

//! Service definition for Realize - Symmetric File Syncer
//!
//! This module defines the RealizeService trait for use with tarpc 0.36.

// Don't warn about types generated by tarpc::service.
#![allow(clippy::too_many_arguments)]

use std::path::PathBuf;

use base64::Engine as _;

pub type Result<T> = std::result::Result<T, RealizeError>;

#[derive(Debug, Clone, Eq, PartialEq, Hash, serde::Serialize, serde::Deserialize)]
pub struct DirectoryId(String);
impl From<String> for DirectoryId {
    fn from(value: String) -> Self {
        Self(value)
    }
}
impl From<&str> for DirectoryId {
    fn from(value: &str) -> Self {
        Self(value.to_string())
    }
}
impl std::fmt::Display for DirectoryId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.0)
    }
}
impl DirectoryId {
    pub fn as_str(&self) -> &str {
        &self.0
    }
    pub fn into_string(self) -> String {
        self.0
    }
}

pub type ByteRange = (u64, u64);

#[derive(Debug, Clone, Eq, PartialEq, serde::Serialize, serde::Deserialize)]
pub struct SyncedFile {
    pub path: PathBuf,
    pub size: u64,
    pub state: SyncedFileState,
}

#[derive(Debug, Clone, Copy, Eq, PartialEq, serde::Serialize, serde::Deserialize)]
pub enum SyncedFileState {
    Final,
    Partial,
}

#[derive(Clone, Eq, PartialEq, serde::Serialize, serde::Deserialize)]
pub struct Hash(pub [u8; 32]);

impl Hash {
    fn base64(&self) -> String {
        base64::prelude::BASE64_STANDARD_NO_PAD.encode(&self.0)
    }

    pub fn zero() -> Self {
        Self([0u8; 32])
    }

    fn is_zero(&self) -> bool {
        for v in self.0 {
            if v != 0 {
                return false;
            }
        }

        true
    }
}

impl std::fmt::Debug for Hash {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self, f)
    }
}

impl std::fmt::Display for Hash {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.is_zero() {
            f.write_str("None")
        } else {
            f.write_str(&self.base64())
        }
    }
}

#[derive(Debug, Clone, Eq, PartialEq, serde::Serialize, serde::Deserialize)]
pub struct Signature(pub Vec<u8>);

#[derive(Debug, Clone, Eq, PartialEq, serde::Serialize, serde::Deserialize)]
pub struct Delta(pub Vec<u8>);

#[derive(Debug, Clone, Copy, Eq, PartialEq, serde::Serialize, serde::Deserialize, Default)]
pub struct Options {
    pub ignore_partial: bool,
}

#[derive(Debug, Clone, Eq, PartialEq, serde::Serialize, serde::Deserialize, Default)]
pub struct Config {
    /// Optional write rate limit in bytes per second.
    pub write_limit: Option<u64>,
}

/// The service trait for file synchronization.
#[tarpc::service]
pub trait RealizeService {
    /// List files in a directory
    async fn list(dir_id: DirectoryId, options: Options) -> Result<Vec<SyncedFile>>;

    /// Send a byte range of a file.
    ///
    /// The 'file_size' argument indicates the intended final size of the file. If the file is larger than this after writing, it should be truncated.
    async fn send(
        dir_id: DirectoryId,
        relative_path: PathBuf,
        range: ByteRange,
        file_size: u64,
        data: Vec<u8>,
        options: Options,
    ) -> Result<()>;

    /// Read a byte range from a file
    async fn read(
        dir_id: DirectoryId,
        relative_path: PathBuf,
        range: ByteRange,
        options: Options,
    ) -> Result<Vec<u8>>;

    /// Mark a partial file as complete
    async fn finish(dir_id: DirectoryId, relative_path: PathBuf, options: Options) -> Result<()>;

    /// Compute a SHA-256 hash of the file at the given path (final or partial).
    async fn hash(
        dir_id: DirectoryId,
        relative_path: PathBuf,
        range: ByteRange,
        options: Options,
    ) -> Result<Hash>;

    /// Delete the file at the given path (both partial and final forms).
    async fn delete(dir_id: DirectoryId, relative_path: PathBuf, options: Options) -> Result<()>;

    /// Calculate a signature for the file at the given path and byte range.
    async fn calculate_signature(
        dir_id: DirectoryId,
        relative_path: PathBuf,
        range: ByteRange,
        options: Options,
    ) -> Result<Signature>;

    /// Compute a delta from the file at the given path and a given signature.
    ///
    /// If the file is empty or too short, the delta is created as if
    /// that specific range contained only 0.
    async fn diff(
        dir_id: DirectoryId,
        relative_path: PathBuf,
        range: ByteRange,
        signature: Signature,
        options: Options,
    ) -> Result<Delta>;

    /// Apply a delta to the file at the given path and byte range.
    async fn apply_delta(
        dir_id: DirectoryId,
        relative_path: PathBuf,
        range: ByteRange,
        file_size: u64,
        delta: Delta,
        options: Options,
    ) -> Result<()>;

    /// Configure the service with the given config (e.g., set write rate limit).
    async fn configure(config: Config) -> Result<Config>;
}

/// Error type used by [RealizeService].
///
/// This is limited, to remain usable through a RPC.
#[derive(thiserror::Error, Debug, serde::Serialize, serde::Deserialize)]
pub enum RealizeError {
    /// Returned by the RealizeService when given an invalid request.
    #[error("Bad request: {0}")]
    BadRequest(String),

    #[error("I/O error: {0}")]
    Io(String),

    #[error("RSync {0:?} error: {1}")]
    Rsync(RsyncOperation, String),

    #[error("Unexpected: {0}")]
    Other(String),
}

#[derive(Debug, serde::Serialize, serde::Deserialize)]
pub enum RsyncOperation {
    Diff,
    Apply,
    Sign,
}

impl From<std::io::Error> for RealizeError {
    fn from(value: std::io::Error) -> Self {
        RealizeError::Io(value.to_string())
    }
}

impl From<anyhow::Error> for RealizeError {
    fn from(value: anyhow::Error) -> Self {
        RealizeError::Other(value.to_string())
    }
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct RangedHash {
    hashes: Vec<RangedHashEntry>,
}

#[derive(Clone, PartialEq, Eq, Debug)]
struct RangedHashEntry {
    range: ByteRange,
    hash: Hash,
}

impl std::fmt::Display for RangedHash {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.hashes.is_empty() {
            write!(f, "Empty")
        } else {
            let range = self.range();
            write!(f, "{}-{}", range.0, range.1)?;
            let complete = self.is_complete(range.1);
            if !complete {
                f.write_str(" INCOMPLETE")?;
            }
            f.write_str(": [")?;
            let mut first = true;
            for RangedHashEntry { range, hash } in &self.hashes {
                if !first {
                    write!(f, " ")?;
                }
                if complete {
                    write!(f, "{}: {}", range.0, hash)?;
                } else {
                    write!(f, "{}-{}: {}", range.0, range.1, hash)?;
                }
                first = false;
            }
            f.write_str("]")?;

            Ok(())
        }
    }
}

impl RangedHash {
    pub fn new() -> Self {
        Self { hashes: vec![] }
    }

    pub fn single(range: ByteRange, hash: Hash) -> Self {
        Self {
            hashes: vec![RangedHashEntry { range, hash }],
        }
    }

    pub fn len(&self) -> usize {
        self.hashes.len()
    }

    pub fn is_empty(&self) -> bool {
        self.hashes.is_empty()
    }

    pub fn add(&mut self, range: ByteRange, hash: Hash) {
        self.hashes.push(RangedHashEntry { range, hash });
        self.hashes.sort_by_key(|e| e.range);
    }

    pub fn range(&self) -> ByteRange {
        (
            self.hashes.first().map_or(0, |e| e.range.0),
            self.hashes.last().map_or(0, |e| e.range.1),
        )
    }

    pub fn is_complete(&self, filesize: u64) -> bool {
        if self.hashes.is_empty() {
            return false;
        }
        let mut expected = 0;
        for e in &self.hashes {
            if e.range.0 != expected {
                return false;
            }
            expected = e.range.1;
        }

        expected == filesize
    }
    pub fn diff(&self, other: &RangedHash) -> (Vec<ByteRange>, Vec<ByteRange>) {
        let mut matches = Vec::new();
        let mut mismatches = Vec::new();
        let mut i = 0;
        let mut j = 0;
        while i < self.hashes.len() && j < other.hashes.len() {
            let a = &self.hashes[i];
            let b = &other.hashes[j];
            if a.range == b.range {
                if a.hash == b.hash {
                    matches.push(a.range);
                } else {
                    mismatches.push(a.range);
                }
                i += 1;
                j += 1;
            } else if a.range.0 < b.range.0 {
                i += 1;
            } else {
                j += 1;
            }
        }
        // Merge contiguous ranges
        let merge = |ranges: Vec<ByteRange>| {
            let mut merged: Vec<ByteRange> = Vec::new();
            for r in ranges {
                if let Some(last) = merged.last_mut() {
                    if (*last).1 == r.0 {
                        (*last).1 = r.1;
                        continue;
                    }
                }
                merged.push(r);
            }
            merged
        };
        (merge(matches), merge(mismatches))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_rangedhash_single() {
        let mut hash = RangedHash { hashes: vec![] };
        hash.add((0, 10), Hash([1; 32]));

        assert_eq!((0, 10), hash.range());
        assert!(hash.is_complete(10));
        assert_eq!(
            "0-10: [0: AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE]",
            hash.to_string()
        );
    }

    #[test]
    fn test_rangedhash_multiple() {
        let mut hash = RangedHash { hashes: vec![] };
        hash.add((0, 10), Hash([1; 32]));
        hash.add((10, 20), Hash([2; 32]));
        assert_eq!(
            format!("{}", hash),
            format!("0-20: [0: {} 10: {}]", Hash([1; 32]), Hash([2; 32]))
        );
    }

    #[test]
    fn test_rangedhash_is_complete() {
        let mut incomplete = RangedHash { hashes: vec![] };
        incomplete.add((0, 10), Hash([1; 32]));
        incomplete.add((10, 20), Hash([2; 32]));
        assert_eq!((0, 20), incomplete.range());

        assert!(incomplete.is_complete(20));
        assert!(!incomplete.is_complete(30));
        assert!(!incomplete.is_complete(10));
    }

    #[test]
    fn test_rangedhash_with_holes() {
        let mut incomplete = RangedHash { hashes: vec![] };
        incomplete.add((0, 10), Hash([1; 32]));
        incomplete.add((20, 30), Hash([2; 32]));

        assert_eq!((0, 30), incomplete.range());
        assert!(!incomplete.is_complete(10));
        assert!(!incomplete.is_complete(20));
        assert!(!incomplete.is_complete(30));

        assert_eq!(
            format!(
                "0-30 INCOMPLETE: [0-10: {} 20-30: {}]",
                Hash([1; 32]),
                Hash([2; 32])
            ),
            incomplete.to_string()
        );
    }

    #[test]
    fn test_rangedhash_empty() {
        let empty = RangedHash { hashes: vec![] };
        assert_eq!((0, 0), empty.range());
        assert!(!empty.is_complete(0));
        assert_eq!("Empty", empty.to_string());
    }

    #[test]
    fn test_rangedhash_diff() {
        let mut a = RangedHash { hashes: vec![] };
        a.add((0, 10), Hash([1; 32]));
        a.add((10, 20), Hash([2; 32]));
        let mut b = RangedHash { hashes: vec![] };
        b.add((0, 10), Hash([1; 32]));
        b.add((10, 20), Hash([3; 32]));

        let (matches, mismatches) = a.diff(&b);
        assert_eq!(matches, vec![(0, 10)]);
        assert_eq!(mismatches, vec![(10, 20)]);

        assert_eq!(a.diff(&b), b.diff(&a));
        assert_eq!(a.diff(&a), (vec![(0, 20)], vec![]));
    }

    #[test]
    fn test_rangedhash_eq_ignores_add_order() {
        let mut unordered_add = RangedHash { hashes: vec![] };
        unordered_add.add((10, 20), Hash([2; 32]));
        unordered_add.add((0, 10), Hash([1; 32]));

        let mut ordered_add = RangedHash { hashes: vec![] };
        ordered_add.add((0, 10), Hash([1; 32]));
        ordered_add.add((10, 20), Hash([2; 32]));

        assert_eq!(unordered_add, ordered_add);
    }
}

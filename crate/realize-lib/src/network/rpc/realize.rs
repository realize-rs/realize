//! Service definition for RealizeService
//!
//! This module defines the RealizeService trait for use with tarpc 0.36.

// Don't warn about types generated by tarpc::service.
#![allow(clippy::too_many_arguments)]

pub mod client;
pub mod metrics;
pub mod server;

use crate::model::{self, Arena, ByteRange, ByteRanges, Delta, Hash, Signature};

/// Convenient shortcut for results containing [RealizeError].
pub type Result<T> = std::result::Result<T, RealizeServiceError>;

/// A file that can be synced through the service, within a directory.
#[derive(Debug, Clone, Eq, PartialEq, serde::Serialize, serde::Deserialize)]
pub struct SyncedFile {
    /// Relative path to a file within the directory.
    ///
    /// Absolute paths and .. are not supported.
    pub path: model::Path,

    /// Size of the file on the current instance, in bytes.
    pub size: u64,
}

/// Configures the behavior of a method on [RealizeService].
#[derive(Debug, Clone, Copy, Eq, PartialEq, serde::Serialize, serde::Deserialize, Default)]
pub struct Options {
    /// If true, only take final files into account. This is usually
    /// set on the source instance, to only move final files.
    pub ignore_partial: bool,
}

/// Configure a specific connection to a [RealizeService] instance.
///
/// This is passed to [RealizeService::configure].
#[derive(Debug, Clone, Eq, PartialEq, serde::Serialize, serde::Deserialize, Default)]
pub struct Config {
    /// Optional write rate limit in bytes per second.
    pub write_limit: Option<u64>,
}

/// Tag that identifies [RealizeService] when connecting.
pub const TAG: &[u8; 4] = b"REAL";

/// The service trait for file synchronization.
#[tarpc::service]
pub trait RealizeService {
    /// List files in a directory
    async fn list(arena: Arena, options: Options) -> Result<Vec<SyncedFile>>;

    /// Send a byte range of a file.
    async fn send(
        arena: Arena,
        relative_path: model::Path,
        range: ByteRange,
        data: Vec<u8>,
        options: Options,
    ) -> Result<()>;

    /// Read a byte range from a file, returning the data.
    ///
    /// Data outside of the range [0, file_size) is returned filled with 0.
    async fn read(
        arena: Arena,
        relative_path: model::Path,
        range: ByteRange,
        options: Options,
    ) -> Result<Vec<u8>>;

    /// Mark a partial file as complete
    async fn finish(arena: Arena, relative_path: model::Path, options: Options) -> Result<()>;

    /// Compute a SHA-256 hash of the file at the given path (final or partial).
    async fn hash(
        arena: Arena,
        relative_path: model::Path,
        range: ByteRange,
        options: Options,
    ) -> Result<Hash>;

    /// Delete the file at the given path (both partial and final forms).
    async fn delete(arena: Arena, relative_path: model::Path, options: Options) -> Result<()>;

    /// Calculate a signature for the file at the given path and byte range.
    async fn calculate_signature(
        arena: Arena,
        relative_path: model::Path,
        range: ByteRange,
        options: Options,
    ) -> Result<Signature>;

    /// Compute a delta from the file at the given path and a given signature.
    ///
    /// Returns the delta and the hash of the data used to compute it.
    async fn diff(
        arena: Arena,
        relative_path: model::Path,
        range: ByteRange,
        signature: Signature,
        options: Options,
    ) -> Result<(Delta, Hash)>;

    /// Apply a delta to the file at the given path and byte range, verifying the hash
    ///
    /// Returns the error [RealizeError::HashMismatch] if, after
    /// applying the patch, the data doesn't match the given hash.
    async fn apply_delta(
        arena: Arena,
        relative_path: model::Path,
        range: ByteRange,
        delta: Delta,
        hash: Hash,
        options: Options,
    ) -> Result<()>;

    /// Truncate file to the given size.
    async fn truncate(
        arena: Arena,
        relative_path: model::Path,
        file_size: u64,
        options: Options,
    ) -> Result<()>;

    /// Configure the service with the given config (e.g., set write rate limit).
    async fn configure(config: Config) -> Result<Config>;
}

/// Error type used by [RealizeService].
///
/// This is limited, to remain usable through a RPC.
#[derive(thiserror::Error, Debug, serde::Serialize, serde::Deserialize)]
pub enum RealizeServiceError {
    /// Returned by the RealizeService when given an invalid request.
    #[error("Bad request: {0}")]
    BadRequest(String),

    #[error("I/O error: {0}")]
    Io(String),

    #[error("RSync {0:?} error: {1}")]
    Rsync(RsyncOperation, String),

    #[error("Unexpected: {0}")]
    Other(String),

    /// Returned by [RealizeService::apply_delta] when the resulting
    /// patch didn't match the hash created by [RealizeService::diff].
    #[error("Hash mismatch after rsync")]
    HashMismatch,
}

#[derive(Debug, serde::Serialize, serde::Deserialize)]
pub enum RsyncOperation {
    Diff,
    Apply,
    Sign,
}

impl From<std::io::Error> for RealizeServiceError {
    fn from(value: std::io::Error) -> Self {
        RealizeServiceError::Io(value.to_string())
    }
}

impl From<anyhow::Error> for RealizeServiceError {
    fn from(value: anyhow::Error) -> Self {
        RealizeServiceError::Other(value.to_string())
    }
}

/// A set of range-specific [struct@Hash]es for a file.
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct RangedHash {
    hashes: Vec<RangedHashEntry>,
}

#[derive(Clone, PartialEq, Eq, Debug)]
struct RangedHashEntry {
    range: ByteRange,
    hash: Hash,
}

impl std::fmt::Display for RangedHash {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.hashes.is_empty() {
            write!(f, "Empty")
        } else {
            let range = self.span();
            write!(f, "{}-{}", range.start, range.end)?;
            let complete = self.is_complete(range.end);
            if !complete {
                f.write_str(" INCOMPLETE")?;
            }
            f.write_str(": [")?;
            let mut first = true;
            for RangedHashEntry { range, hash } in &self.hashes {
                if !first {
                    write!(f, " ")?;
                }
                if complete {
                    write!(f, "{}: {}", range.start, hash)?;
                } else {
                    write!(f, "{}-{}: {}", range.start, range.end, hash)?;
                }
                first = false;
            }
            f.write_str("]")?;

            Ok(())
        }
    }
}

impl RangedHash {
    /// Create an empty [RangedHash].
    pub fn new() -> Self {
        Self { hashes: vec![] }
    }

    /// Create a [RangedHash] with a single hash.
    pub fn single(range: ByteRange, hash: Hash) -> Self {
        let mut hashes = Vec::new();
        hashes.push(RangedHashEntry { range, hash });
        RangedHash { hashes }
    }

    /// The number of hashes within this instance.
    pub fn len(&self) -> usize {
        self.hashes.len()
    }

    /// Return true if there are any hashes within this instance.
    pub fn is_empty(&self) -> bool {
        self.hashes.is_empty()
    }

    /// Add a hash to this instance.
    pub fn add(&mut self, range: ByteRange, hash: Hash) {
        self.hashes.push(RangedHashEntry { range, hash });
        self.hashes.sort_by_key(|e| e.range.clone());
    }

    /// Return the byte range covered by the hashes in this instance,
    /// ignoring any holes.
    pub fn span(&self) -> ByteRange {
        ByteRange {
            start: self.hashes.first().map_or(0, |e| e.range.start),
            end: self.hashes.last().map_or(0, |e| e.range.end),
        }
    }

    /// Return a representation of the ranges covered by hashes within
    /// this instance.
    ///
    /// Ideally, there's just one range, starting at 0 and ending at
    /// `file_size`, but that's not always the case. Check it with
    /// [RangedHash::is_complete].
    pub fn ranges(&self) -> ByteRanges {
        ByteRanges::from_range_refs(self.hashes.iter().map(|e| &e.range))
    }

    /// Return true if the range covers the range [0, `filesize`).
    pub fn is_complete(&self, filesize: u64) -> bool {
        if self.hashes.is_empty() {
            return false;
        }
        let mut expected = 0;
        for e in &self.hashes {
            if e.range.start != expected {
                return false;
            }
            expected = e.range.end;
        }

        expected == filesize
    }

    /// Detailled comparison of this instance with another.
    ///
    /// Return two [ByteRanges]: (matching, non-matching)
    pub fn diff(&self, other: &RangedHash) -> (ByteRanges, ByteRanges) {
        let mut matches = Vec::new();
        let mut mismatches = Vec::new();
        let mut i = 0;
        let mut j = 0;
        while i < self.hashes.len() && j < other.hashes.len() {
            let a = &self.hashes[i];
            let b = &other.hashes[j];
            if a.range == b.range {
                if a.hash == b.hash {
                    matches.push(a.range.clone());
                } else {
                    mismatches.push(a.range.clone());
                }
                i += 1;
                j += 1;
            } else if a.range.start < b.range.start {
                i += 1;
            } else {
                j += 1;
            }
        }

        (
            ByteRanges::from_ranges(matches),
            ByteRanges::from_ranges(mismatches),
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_rangedhash_single() {
        let mut hash = RangedHash { hashes: vec![] };
        hash.add(ByteRange { start: 0, end: 10 }, Hash([1; 32]));

        assert_eq!(ByteRange { start: 0, end: 10 }, hash.span());
        assert!(hash.is_complete(10));
        assert_eq!(
            "0-10: [0: AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE]",
            hash.to_string()
        );
    }

    #[test]
    fn test_rangedhash_multiple() {
        let mut hash = RangedHash { hashes: vec![] };
        hash.add(ByteRange { start: 0, end: 10 }, Hash([1; 32]));
        hash.add(ByteRange { start: 10, end: 20 }, Hash([2; 32]));
        assert_eq!(
            format!("{}", hash),
            format!("0-20: [0: {} 10: {}]", Hash([1; 32]), Hash([2; 32]))
        );
    }

    #[test]
    fn test_rangedhash_is_complete() {
        let mut incomplete = RangedHash { hashes: vec![] };
        incomplete.add(ByteRange { start: 0, end: 10 }, Hash([1; 32]));
        incomplete.add(ByteRange { start: 10, end: 20 }, Hash([2; 32]));
        assert_eq!(ByteRange { start: 0, end: 20 }, incomplete.span());

        assert!(incomplete.is_complete(20));
        assert!(!incomplete.is_complete(30));
        assert!(!incomplete.is_complete(10));
    }

    #[test]
    fn test_rangedhash_with_holes() {
        let mut incomplete = RangedHash { hashes: vec![] };
        incomplete.add(ByteRange { start: 0, end: 10 }, Hash([1; 32]));
        incomplete.add(ByteRange { start: 20, end: 30 }, Hash([2; 32]));

        assert_eq!(ByteRange { start: 0, end: 30 }, incomplete.span());
        assert!(!incomplete.is_complete(10));
        assert!(!incomplete.is_complete(20));
        assert!(!incomplete.is_complete(30));

        assert_eq!(
            format!(
                "0-30 INCOMPLETE: [0-10: {} 20-30: {}]",
                Hash([1; 32]),
                Hash([2; 32])
            ),
            incomplete.to_string()
        );
    }

    #[test]
    fn test_rangedhash_empty() {
        let empty = RangedHash { hashes: vec![] };
        assert_eq!(ByteRange { start: 0, end: 0 }, empty.span());
        assert!(!empty.is_complete(0));
        assert_eq!("Empty", empty.to_string());
    }

    #[test]
    fn test_rangedhash_diff() {
        let mut a = RangedHash { hashes: vec![] };
        a.add(ByteRange { start: 0, end: 10 }, Hash([1; 32]));
        a.add(ByteRange { start: 10, end: 20 }, Hash([2; 32]));
        let mut b = RangedHash { hashes: vec![] };
        b.add(ByteRange { start: 0, end: 10 }, Hash([1; 32]));
        b.add(ByteRange { start: 10, end: 20 }, Hash([3; 32]));

        let (matches, mismatches) = a.diff(&b);
        assert_eq!(matches, ByteRanges::for_range(ByteRange::new(0, 10)));
        assert_eq!(mismatches, ByteRanges::for_range(ByteRange::new(10, 20)));

        assert_eq!(a.diff(&b), b.diff(&a));
        assert_eq!(
            a.diff(&a),
            (
                ByteRanges::for_range(ByteRange::new(0, 20)),
                ByteRanges::new()
            )
        );
    }

    #[test]
    fn test_rangedhash_eq_ignores_add_order() {
        let mut unordered_add = RangedHash { hashes: vec![] };
        unordered_add.add(ByteRange { start: 10, end: 20 }, Hash([2; 32]));
        unordered_add.add(ByteRange { start: 0, end: 10 }, Hash([1; 32]));

        let mut ordered_add = RangedHash { hashes: vec![] };
        ordered_add.add(ByteRange { start: 0, end: 10 }, Hash([1; 32]));
        ordered_add.add(ByteRange { start: 10, end: 20 }, Hash([2; 32]));

        assert_eq!(unordered_add, ordered_add);
    }
}
